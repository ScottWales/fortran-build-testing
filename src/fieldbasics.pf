! Basic stuff a field needs to do, just making sure types and overloads work

@test
subroutine construct()
    use field_mod
    type(field) :: a

    a%placeholder = 0
end subroutine

@test
subroutine set()
    use field_mod
    type(scalarfield) :: a

    a = 1
    a = 9.99
end subroutine

@test
subroutine assign()
    use field_mod
    type(field) :: a, b

    b = a
end subroutine

@test
subroutine add()
    use field_mod
    type(field) :: a, b, c

    c = a + b
end subroutine

@test
subroutine scale()
    use field_mod
    type(field) :: a, b

    b = a*(-1)
    b = (-1)*a
    b = a / 2
end subroutine

@test
subroutine negate()
    use field_mod
    type(field) :: a, b

    b = -a
end subroutine

@test
subroutine subtract()
    use field_mod
    type(field) :: a, b, c

    c = a - b
end subroutine

function pat(u, v, w) result(z)
    real, intent(in) :: u
    real, intent(in) :: v
    real, intent(in) :: w
    real :: z

    ! ignore unused arguments
    z=u+v+w

    z = 1
end function

@test
subroutine assign_pattern()
    use field_mod
    interface
        function pat(u, v, w) result(z)
            real, intent(in) :: u
            real, intent(in) :: v
            real, intent(in) :: w
            real :: z
        end function 
    end interface

    type(scalarfield) :: a

    call a%pattern(pat)
end subroutine

@test
subroutine vectorops()
    use field_mod
    type(scalarfield) :: s
    type(vectorfield) :: v

    v = grad(s)
    s = div(v)
end subroutine
