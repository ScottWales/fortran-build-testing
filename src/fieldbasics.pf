! Basic stuff a field needs to do, just making sure types and overloads work

@test
subroutine construct()
    use field_mod
    type(field) :: a

    a%placeholder = 0
end subroutine

@test
subroutine set()
    use field_mod
    type(scalarfield) :: a

    a = 1
    a = 9.99
end subroutine

@test
subroutine assign()
    use field_mod
    type(field) :: a, b
    type(scalarfield) :: sa, sb
    type(vectorfield) :: va, vb

    b = a
    sb = sa
    vb = va
end subroutine

@test
subroutine add()
    use field_mod
    type(scalarfield) :: sa, sb, sc
    type(vectorfield) :: va, vb, vc

    sc = sa + sb
    vc = va + vb
    sc = sa - sb
    vc = va - vb
end subroutine

@test
subroutine scale()
    use field_mod
    type(scalarfield) :: sa, sb
    type(vectorfield) :: va, vb

    sb = sa*(-1)
    sb = (-1)*sa
    sb = sa / 2
    vb = va*(-1)
    vb = (-1)*va
    vb = va / 2
end subroutine

@test
subroutine negate()
    use field_mod
    type(scalarfield) :: sa, sb
    type(vectorfield) :: va, vb

    sb = -sa
    vb = -va
end subroutine

function pat(u, v, w) result(z)
    real, intent(in) :: u
    real, intent(in) :: v
    real, intent(in) :: w
    real :: z

    ! ignore unused arguments
    z=u+v+w

    z = 1
end function

@test
subroutine assign_pattern()
    use field_mod
    interface
        function pat(u, v, w) result(z)
            real, intent(in) :: u
            real, intent(in) :: v
            real, intent(in) :: w
            real :: z
        end function 
    end interface

    type(scalarfield) :: a

    call a%pattern(pat)
end subroutine

@test
subroutine vectorops()
    use field_mod
    type(scalarfield) :: s
    type(vectorfield) :: v

    v = grad(s)
    s = div(v)
end subroutine
