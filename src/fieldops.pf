! Field operations

! Performing operations on a field creates a statement tree of fieldops
! A fieldop gets evaluated when it's assigned to a plain field
@test
subroutine operations()
    use field_mod
    type(scalarfield) :: sf

    sf = 1.0 * sf
end subroutine

! Convert between scalar and vector fields - trying to assign them directly is a
! syntax error
@test
subroutine convert()
    use field_mod
    type(scalarfield) :: sf
    type(vectorfield) :: vf

    vf = grad(sf)
end subroutine

! Chain operations to create bigger statements - optimisation happens in the
! background so users only care about whole fields, not loops and halos
@test
subroutine chain()
    use field_mod
    type(scalarfield) :: sf
    type(vectorfield) :: vf

    vf = grad(1.0 * sf)
end subroutine
    
! We have all kinds of basic operations
@test
subroutine basicops()
    use field_mod
    type(scalarfield) :: sf
    type(vectorfield) :: vf

    sf = -sf     ! Negate
    vf = -vf
    sf = 1.0/sf  ! Elementwise inverse
    vf = sf * vf ! Scale vector field by scalar field
    vf = vf + vf ! Add fields
end subroutine


! These add up to represent complex operations, written out in readable syntax
@test
subroutine wind()
    use field_mod
    type(scalarfield) :: rho, p
    type(vectorfield) :: DuDt, G, u
    real :: dt

    DuDt = -1.0/rho * grad(p) + G
    u = u + dt * DuDt
end subroutine

! Some tests to make sure that the internals work
! Operations are evaluated lazily to increase cache hits - instead of
!     do i
!        a(i) = b(i) + c(i)
!     end
!     do i
!        d(i) = 2 * a(i)
!     end
! loops will get automatically merged:
!     do i
!        d(i) = 2 * (b(i) + c(i))
!     end do
! Unfortunately we can't get all the benefits of C++'s expression templates
! since these operations can't be inlined, but it should allow a decent amount
! of expressiveness.
@test
subroutine basic_internals()
    use field_mod
    use pfunit_mod
    type(scalarfield) :: a, b, c

    a = 1.0
    b = a
    @assertTrue(a == b)

    a = -b
    c = -1.0
    @assertTrue(a == c)

    a = 2.0 * b
    c = 2.0
    @assertTrue(a == c)

    a = b + b
    c = 2.0 * b
    @assertTrue(a == c)

    a = 2.0
    b = 1.0/a
    c = 0.5
    @assertTrue(b == c)
end subroutine
