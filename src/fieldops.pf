! Field operations

! An operation gets evaluated when it's assigned to a plain field
@test
subroutine assign()
    use field_mod
    type(scalarfield) :: sf
    type(fieldop_sf)  :: op

    sf = op
end subroutine

! Performing operations on a field creates a statement tree
@test
subroutine operations()
    use field_mod
    type(scalarfield) :: sf

    sf = 1.0 * sf
end subroutine

! Convert between scalar and vector fields
@test
subroutine convert()
    use field_mod
    type(scalarfield) :: sf
    type(vectorfield) :: vf

    vf = grad(sf)
end subroutine

! Chain operations
@test
subroutine chain()
    use field_mod
    type(scalarfield) :: sf
    type(vectorfield) :: vf

    vf = grad(1.0 * sf)
end subroutine
    
! We have all kinds of basic operations
@test
subroutine basicops()
    use field_mod
    type(scalarfield) :: sf
    type(vectorfield) :: vf

    sf = -sf ! Negate
    vf = -vf
    sf = 1.0/sf ! Elementwise inverse
    vf = sf * vf ! Scale vector field by scalar field
    vf = vf + vf ! Add fields
end subroutine


! Eventually we can represent complex operations, written out in readable syntax
@test
subroutine wind()
    use field_mod
    type(scalarfield) :: rho, p
    type(vectorfield) :: DuDt, G

    DuDt = -1.0/rho * grad(p) + G
end subroutine

! Now let's make the internals work
@test
subroutine set()
    use field_mod
    type(scalarfield) :: sf

    sf = 1.0
end subroutine
